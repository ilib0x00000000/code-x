#include <iostream>

using namespace std;

/**
 * 对象之间的关系
 *
 * 1. 用一个对象初始化另一个对象
 * 2. 用一个对象赋值给另一个对象
 *
 * 3. 用匿名对象初始化另一个对象
 * 4. 用匿名对象赋值给另一个对象
 *
 * 5. 函数的返回值（匿名对象）初始化一个对象
 * 6. 函数的返回值（匿名对象）赋值给一个对象
 * 7. 函数的返回值（匿名对象）抛弃
 *
 * 8. 函数的返回值（匿名对象）的引用初始化一个对象
 * 9. 函数的返回值（匿名对象）的引用赋值给一个对象
 * 10. 函数的返回值（匿名对象）的引用抛弃
 */

class Test
{
public:
	Test()              { value=0;        cout << "调用了无参构造函数" << endl; }
	Test(int v)         { value=v;        cout << "调用了带参构造函数" << endl; }
	Test(const Test& nt){ value=nt.value; cout << "调用了拷贝构造函数" << endl; }
	~Test()             { cout << "这里调用了析构函数" << endl; }
private:
	int value;
};

Test rtnobj(void)
{
	/**
	 * 分配一个栈变量
	 */
	Test t(100);

	return t;
}

Test& rtnobj_r(void)
{
	/**
	 * 分配一个栈变量
	 * 返回一个对象的引用
	 */
	Test t(100);

	return t;
}

int main(int argc, char const *argv[])
{
	objplay6();

	cout << "主函数结束" << endl;

	return 0;
}

void objplay0(void)
{
	/**
	 * 用一个对象初始化另一个对象
	 *
	 * 输出：
	 * 	调用了带参构造函数
	 * 	调用了拷贝构造函数
	 * 	这里调用了析构函数
	 * 	这里调用了析构函数
	 *
	 * 结论：使用一个对象初始化另一个对象时，会调用拷贝构造函数
	 */
	Test t1(10);
	Test t2 = t1;
}

void objplay1(void)
{
	/**
	 * 用一个对象赋值给另一个对象
	 *
	 * 输出：
	 * 	调用了带参构造函数
	 * 	调用了无参构造函数
	 * 	这里调用了析构函数
	 * 	这里调用了析构函数
	 */
	Test t1(10);
	Test t2;

	t2 = t1;
}

void objplay2(void)
{
	/**
	 * 用匿名对象初始化一个对象
	 *
	 * 输出：
	 * 	调用了带参构造函数
	 * 	这里调用了析构函数
	 *
	 * 结论：使用匿名对象初始化一个对象时，只存在一个对象，只调用了一次无参（带参）构造函数，只调用了一次析构函数
	 */
	Test t1 = Test(10);
	// 等价于: 
	// Test t1(10);
}


void objplay3(void)
{
	/**
	 * 使用匿名对象赋值给两一个对象
	 *
	 * 输出：
	 * 	调用了无参构造函数
	 * 	调用了带参构造函数
	 * 	这里调用了析构函数
	 * 	这里调用了析构函数
	 *
	 * 结论：使用一个匿名对象给另一个对象赋值，不会调用拷贝构造函数
	 */
	Test t1;
	t1 = Test(10);
}


/********************************************下面的测试与编译器相关******************************************************/
/**
 * Mac与Windows上编译运行结果不同
 */
void objplay6(void)
{
	/**
	 * 函数返回值（匿名对象）被抛弃
	 *
	 * 输出：
	 * 	调用了带参构造函数
	 * 	调用了拷贝构造函数
	 * 	这里调用了析构函数
	 * 	这里调用了析构函数
	 * 	函数的返回值被抛弃
	 * 	主函数结束
	 */
	rtnobj();

	cout << "函数的返回值被抛弃" << endl;
}

/**
 * Mac与Windows上编译运行结果不同
 */
void objplay5(void)
{
	/**
	 * 用函数返回值（匿名对象）赋值给另一个对象
	 *
	 * Windows输出：
	 * 	调用了无参构造函数
	 * 	调用了带参构造函数
	 * 	调用了拷贝构造函数
	 * 	这里调用了析构函数
	 * 	这里调用了析构函数
	 * 	t的生命域还没有结束
	 * 	这里调用了析构函数
	 * 	主函数结束
	 */
	Test t;

	t = rtnobj();

	cout << "t的生命域还没有结束" << endl;
}

/**
 * Mac与Windows上编译运行结果不同
 */
void objplay4(void)
{
	/**
	 * 函数的返回值（匿名对象）初始化一个对象
	 *
	 * 输出：
	 * 	调用了带参构造函数
	 * 	调用了拷贝构造函数
	 * 	这里调用了析构函数
	 * 	t对象还存活
	 * 	这里调用了析构函数
	 * 	主函数结束
	 */
	Test t = rtnobj();

	cout << "t对象还存活" << endl;
}
